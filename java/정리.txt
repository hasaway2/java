1. Token 인증
- 일반적인 로그인 인증은 로그인한 사이트에서만 유효
- 네이버에 로그인하면 네이버페이, tving 등등의 사이트에서도 유효
  토큰 로그인은 로그인처럼 보이지만 내부구현은 다르다
- 작동 순서
  1.네이버에 로그인하면 네이버가 나(사용자)에게 Token을 발급한다
  2.내가 네이버페이 쇼핑사이트에서 결제를 할 경우
  		내가 가진 토큰이 쇼핑사이트에 전송된다
  		쇼핑사이트는 받은 토큰의 내용이 정확힌지 네이버에게 확인받는다
  3.확인이 성공하면 결제가 이뤄진다 
- 나의 이득
	보안을 내가 아닌 네이버에 의존한다 -> 신뢰성이 높고 빠른 조치가 가능
- 문제점
	네이버는 믿을 수 있어...그런데 사용자를 어떻게 믿지?
	토큰은 수명이 매우 짧다(보통 30분내외) -> 토큰 재발급 절차가 필요
	이런 토큰 관리, 토큰 재발급등을 규정한 규약 --> OAuth
	
2. Access Modifier
	class Sample {
		public int a;	
		int b;							// defalut
		protected int c;
		private int d;
	}
- public			누구나 접근 가능
- default			같은 패키지인 경우 접근 가능 -> 보통 권장X
- protected		자식이면 접근 가능
- private			아무도 접근 X

3. maven
- 의존(dependency)
	객체 A가 객체 B를 사용할 때 "의존"한다고 한다
		사람은 스마트폰에 의존한다
		직장인은 출퇴근할 때 탈것에 의존한다
- 내가 만든 프로젝트 = 내가 작성한 코드 + 의존하는 라이브러리
- 라이브러리를 관리해 주는 프로그램 : maven 또는 gradle
  빌드(build)도구, 의존성 관리 도구
  
4. 객체지향 프로그래밍이란?
- 객체의 설계도인 클래스를 작성하고, 객체를 생성하고 프로그램을 구성한다
- 객체는 소프트웨어 부품 -> 자기일은 자기가 알아서 한다
- 자바스크립트는 클래스없이 객체를 바로 만드네 -> 객체기반 프로그래밍
	const todo ={tno:1, title:'자바공부', finish:false};

5. 객체지향 프로그래밍 구성요소
- 캡슐화 : 값(필드)과 기능(메소드)를 모아 클래스를 만들어라
- 정보은닉
		숨겨라(private) -> 케이스를 씌워라
		꼭 필요한 기능만 공개해라
- 상속
- 다형성 
		상황에 따라 다르게 동작한다
		overload
		override
  
6. overload
- 함수 이름이 겹쳐도 된다
    단 인자가 다르다면....
- 자바는 함수이름으로 함수를 구별X
  인자와 함수이름으로 함수를 구별

7. static
- 꼭 필요한 경우에만 객체를 만들자
		new 연산의 비용이 비싸고 객체가 많으면 관리 부담이 커진다
- static
		객체를 만들지 않고 공유하는 필드나 메소드를 지정
		static은 객체없이도 사용이 가능하다(new 하기전에 사용이 가능하다)
		static은 this를 사용할 수 없다
- static은 static끼리만 접근할 수 있다		
- 엔티티 클래스 : 값을 저장하는 클래스
  작업 클래스 : 전부 static method

7. 디자인 패턴
- 개발 중에 자주 만나는 문제와 그 해결책을 정의해놓은 것
- Builder 
	객체 생성의 어려움을 덜어준다

8. 디자인 패턴 : Singleton

9. 상속

10. override

11. 추상메소드와 추상클래스

12. 인터페이스

13. 예외처리
















